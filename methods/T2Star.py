import numpy as np


class T2Star():
    """Package containing algorithms that calculate parameter maps
    of the MRI scans acquired during the UKRIN-MAPS project.

    Attributes
    ----------
    See parameters of __init__ class

    """

    def __init__(self, pixelArray, echoList):
        """Initialise a T2StarCode class instance.

        Parameters
        ----------
        pixelArray : np.ndarray of N-dimensions
        echoList: np.ndarray containing echo times"""

        self.pixelArray = pixelArray
        self.echoList = echoList

    # Consider splitting these methods into SubClasses at some point.
    # Could create a Diffusion Toolbox where BValues are an atribute.
    # Or Fitting, where Inversion Time and Echo Time are attributes.
    # https://www.youtube.com/watch?v=RSl87lqOXDE

    def T2StarNottingham(self):
        """
        Generates a T2* map from a series of volumes collected with different
        echo times.

        Parameters
        ----------
        pixelArray : 4D/3D array
            A 4D/3D array containing the signal from each voxel at each
            echo time i.e. the dimensions of the array are [x, y, z, TE].
        echoList : Array
            An array of the echo times used for the last dimension of the
            raw data.

        Returns
        -------
        t2star : 3D array
            An array containing the T2* map generated by the function with T2*
            measured in milliseconds.
        r2star : 3D array
            An array containing the R2* map generated by the function with R2*
            measured in milliseconds.
        m0 : 3D array
            An array containing the M0 map generated by the function.
        """
        try:
            self.pixelArray[self.pixelArray == 0] = 1E-10
            # If raw data is 2D (3D inc echo times) then add a dimension so it
            # can be processed in the same way as 3D data
            if len(self.pixelArray.shape) == 3:
                self.pixelArray = np.expand_dims(self.pixelArray, 2)

            t2star = np.zeros(self.pixelArray.shape[0:3])
            r2star = np.zeros(self.pixelArray.shape[0:3])
            m0 = np.zeros(self.pixelArray.shape[0:3])
            with np.errstate(invalid='ignore', over='ignore'):
                for s in range(self.pixelArray.shape[2]):
                    for x in range(np.shape(self.pixelArray)[0]):
                        for y in range(np.shape(self.pixelArray)[1]):
                            noise = 0.0
                            sd = 0.0
                            s_w = 0.0
                            s_wx = 0.0
                            s_wx2 = 0.0
                            s_wy = 0.0
                            s_wxy = 0.0
                            for d in range(self.pixelArray.shape[3]):
                                noise = noise + self.pixelArray[x, y, s, d]
                                sd = sd + self.pixelArray[x, y, s, d] * \
                                    self.pixelArray[x, y, s, d]
                            noise = noise / self.pixelArray.shape[3]
                            sd = sd / self.pixelArray.shape[3] - noise ** 2
                            sd = sd ** 2
                            sd = np.sqrt(sd)
                            for d in range(self.pixelArray.shape[3]):
                                te_tmp = self.echoList[d]
                                if self.pixelArray[x, y, s, d] > sd:
                                    sigma = np.log(
                                        self.pixelArray[x, y, s, d] /
                                        (self.pixelArray[x, y, s, d] - sd))
                                    sig = self.pixelArray[x, y, s, d]
                                    weight = 1 / (sigma ** 2)
                                else:
                                    sigma = np.log(
                                        self.pixelArray[x, y, s, d] / 0.0001)
                                    sig = np.log(self.pixelArray[x, y, s, d])
                                    weight = 1 / (sigma ** 2)
                                weight = 1 / (sigma ** 2)
                                s_w = s_w + weight
                                s_wx = s_wx + weight * te_tmp
                                s_wx2 = s_wx2 + weight * te_tmp ** 2
                                s_wy = s_wy + weight * sig
                                s_wxy = s_wxy + weight * te_tmp * sig
                            delta = (s_w * s_wx2) - (s_wx ** 2)
                            if ((delta == 0.0) or (np.isinf(delta))
                               or (np.isnan(delta))):
                                t2star[x, y, s] = 0
                                r2star[x, y, s] = 0
                                m0[x, y, s] = 0
                            else:
                                a = (1 / delta) * (s_wx2 * s_wy - s_wx * s_wxy)
                                b = (1 / delta) * (s_w * s_wxy - s_wx * s_wy)
                                t2stars_temp = np.real(-1 / b)
                                r2stars_temp = np.real(-b)
                                m0_temp = np.real(np.exp(a))
                                if (t2stars_temp < 0) or (t2stars_temp > 500):
                                    t2star[x, y, s] = 0
                                    r2star[x, y, s] = 0
                                    m0[x, y, s] = 0
                                else:
                                    t2star[x, y, s] = t2stars_temp
                                    r2star[x, y, s] = r2stars_temp
                                    m0[x, y, s] = m0_temp
            del t2stars_temp, r2stars_temp, m0_temp, delta
            return t2star, r2star, m0
        except Exception as e:
            print('Error in function T2Star.T2StarNottingham: ' + str(e))

    def T2StarJoao(self):
        """
        Generates a T2* map from a series of volumes
        collected with different echo times.
        It's a rewritten version of T2StarNottingham with a few modifications.

        Parameters
        ----------
        pixelArray : 4D/3D array
            A 4D/3D array containing the signal from each voxel
            at each echo time i.e. the dimensions of the array
            are [x, y, z, TE].
        echoList : Array
            An array of the echo times used for the
            first dimension of the raw data.

        Returns
        -------
        t2Star : 3D array
            An array containing the T2* map generated by
            the function with T2* measured in milliseconds.
        r2star : 3D array
        """
        try:
            self.pixelArray[self.pixelArray == 0] = 1E-10
            # If raw data is 2D (3D inc echo times) then add a dimension
            # so it can be processed in the same way as 3D data
            if len(self.pixelArray.shape) == 3:
                self.pixelArray = np.expand_dims(self.pixelArray, 2)
            numberEchoes = len(self.echoList)
            matrixOnes = np.ones(np.shape(np.squeeze(self.pixelArray[..., 0])))
            with np.errstate(invalid='ignore', over='ignore'):
                noise = np.sum(self.pixelArray, axis=3) /
                (numberEchoes * matrixOnes)
                sd = (np.absolute(np.sum(np.square(self.pixelArray), axis=3)
                      / (numberEchoes * matrixOnes) - np.square(noise)))
                s_w = s_wx = s_wx2 = np.zeros(np.shape(matrixOnes))
                s_wy = s_wxy = s_w
                for echo in range(numberEchoes):
                    te = self.echoList[echo] * 0.001 * matrixOnes
                    # Conversion from ms to seconds
                    sigma = sig = np.zeros(np.shape(matrixOnes))
                    matrixIterator = np.nditer(sd, flags=['multi_index'])
                    while not matrixIterator.finished:
                        index = matrixIterator.multi_index
                        if self.pixelArray[index][echo] > sd[index]:
                            sigma[index] = (np.log(self.pixelArray[index][echo]
                                            / (self.pixelArray[index][echo]
                                            - sd[index])))
                            sig[index] = self.pixelArray[index][echo]
                        else:
                            sigma[index] = (np.log(self.pixelArray[index][echo]
                                            / 0.0001))
                            sig[index] = np.log(self.pixelArray[index][echo])
                        matrixIterator.iternext()
                    weight = matrixOnes / np.square(sigma)
                    s_w = s_w + weight
                    s_wx = s_wx + (weight * te)
                    s_wx2 = s_wx2 + weight * np.square(te)
                    s_wy = s_wy + weight * sig
                    s_wxy = s_wxy + weight * te * sig
                delta = (s_w * s_wx2) - (np.square(s_wx))
                b = (matrixOnes / delta) * (s_w * s_wxy - s_wx * s_wy)
                t2Star = np.real(-matrixOnes / b)
                conditions = (np.isinf(t2Star)) | (np.isnan(t2Star)) |
                (t2Star < 0.0) | (t2Star > 500.0)
                t2Star = np.where(conditions, 0.0, t2Star)
            return t2Star
        except Exception as e:
            print('Error in function T2Star.T2StarJoao: ' + str(e))

    def R2Star(self):
        """
        Generates a R2* map from a series of volumes collected
        with different echo times. It calls T2StarJoao().

        Parameters
        ----------
        pixelArray : 4D/3D array
            A 4D/3D array containing the signal from each voxel
            at each echo time i.e. the dimensions of the array
            are [x, y, z, TE].
        echoList : Array
            An array of the echo times used for the
            first dimension of the raw data.

        Returns
        -------
        r2Star : 3D array
            An array containing the R2* map generated
            by the function with R2* measured in seconds.
        """
        try:
            r2Star = np.ones(np.shape(self.pixelArray))/self.T2StarJoao()
            return r2Star
        except Exception as e:
            print('Error in function T2Star.R2Star: ' + str(e))
